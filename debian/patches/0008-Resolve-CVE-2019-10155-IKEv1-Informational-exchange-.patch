From: Libreswan Team <team@libreswan.org>
Date: Mon, 10 Jun 2019 22:55:34 +0100
Subject: Resolve CVE-2019-10155: IKEv1 Informational exchange integrity check
 failure

This alert (and any possible updates) is available at the following URLs:
https://libreswan.org/security/CVE-2019-10155/

The Libreswan Project has found a vulnerability in its processing IKEv1
informational exchange packets. These packets are encrypted and integrity
protected using the established IKE SA encryption and integrity keys, but
as a receiver, the integrity check value (ICV) was not verified for IKEv1
Informational Exchange packets. The code containing the vulnerability is
also present in openswan and older strongswan releases.

The impact of this vulnerability is low, as it cannot be exploited.
(for libreswan; for strongswan and openswan see below)

Vulnerable versions:    libreswan < 3.29
                        strongswan < 5.0
                        openswan - all versions  (as of writing: 2.6.51.3)

Not vulnerable: libreswan 3.29 and later, strongswan 5.0 and later, freeswan

Vulnerability information
=========================
IKEv1 informational packets are not integrity checked. As these packets
are encrypted under the negotiated IKE SA's encryption key, the impact of
this is very limited. An attacker would have no access to the encryption
key, meaning an on-path attacker can at best send mangled messages that
would be processed for decryption, but these messages once decrypted would
result in nonsense data that would be rejected as an invalid IKE packet.

Even if the attacker somehow managed to accidentally forge an encrypted
message that would decrypt in a valid IKE packet (or if it would otherwise
obtain the encryption key of the IKE session), the damage it can do is
limited, as the IKEv1 informational exchange is only used for two type of
messages: Dead Peer Detection (DPD) messages and Delete/Notify messages
terminating IPsec and IKE SA's. Since the attacker needs to be on-path
for this attack, it is much easier for the attacker to filter the packets
to accomplish the same thing. An IKE point that required a connection
to be established, would also re-establish a connection that is brought
down by a Notify/Delete message. As such, the impact is deemed low.

Exploitation
============
There is no known method for exploiting this vulnerability for libreswan.

Due to the missing the integrity check, a concern was investigated to
see if the vulnerability could be used as an oracle to attack the IKE
SA encryption key. Due to the way libreswan has implemented encryption,
using the NSS crypto library, no RSA padding attacks are possible. While
it would be possible to determine the unencrypted message length, this
information yields no useful information to an attacker.

For strongswan, no versions have been vulnerable since 2012, when the
shared vulnerable code was replaced by a new IKEv1 implementation that
is not vulnerable. Those old versions would be vulnerable to the openswan
RSA oracle attack as well.

For openswan versions before v2.6.51.3 (released March 2019) that are not
compiled to use the NSS crypto library, there is a risk these versions
are vulnerable to an RSA oracle attack that could yield the IKE SA
encryption key. While older versions of Red Hat Enterprise Linux (RHEL)
used to support openswan, these are not vulnerable to an RSA oracle attack
as these versions used the NSS crypto library. All current versions of
RHEL now use libreswan and cannot be exploited. If still using openswan,
please consult your vendor or upgrade to libreswan.

Workaround
==========
A possible workaround is to reconfigure IKEv1 connections to use IKEv2,
using the keyword ikev2=insist. However, this must be supported and
allowed by the IKE peer as well.

History
=======
All vulnerable versions listed above, inherited the vulnerable
code from the patched freeswan codebase known at the time as
"super-freeswan". Freeswan itself never supported any Informational
Exchange message. Strongswan and openswan are forks of "super-freeswan",
and libreswan is a fork/continuation of openswan-2.6.38. Strongswan
removed the "super-freeswan" inherited code in version 5.0.0.

Credits
=======
This vulnerability was found by the Libreswan Project
---
 programs/pluto/ikev1.c       | 26 ++++++++++++++++++++++++++
 programs/pluto/ikev1_quick.c |  8 ++++----
 programs/pluto/ipsec_doi.h   |  5 +++++
 3 files changed, 35 insertions(+), 4 deletions(-)

diff --git a/programs/pluto/ikev1.c b/programs/pluto/ikev1.c
index 38dfe06..c321e28 100644
--- a/programs/pluto/ikev1.c
+++ b/programs/pluto/ikev1.c
@@ -2134,6 +2134,32 @@ void process_packet_tail(struct msg_digest **mdp)
 		}
 	}
 
+	if (md->hdr.isa_xchg == ISAKMP_XCHG_INFO &&
+	    md->hdr.isa_np == ISAKMP_NEXT_HASH) {
+		pb_stream *const hash_pbs = &(md)->chain[ISAKMP_NEXT_HASH]->pbs;
+		u_char hash_val[MAX_DIGEST_LEN];
+		size_t hash_len = quick_mode_hash12(hash_val, hash_pbs->roof,
+						    md->message_pbs.roof,
+						    st, &md->hdr.isa_msgid, FALSE);
+		if (pbs_left(hash_pbs) != hash_len) {
+			loglog(RC_LOG_SERIOUS,
+			       "received 'informational' message HASH(1) data is the wrong length (received %zu bytes but expected %zu)",
+			       pbs_left(hash_pbs), hash_len);
+			return;
+		}
+		if (!memeq(hash_pbs->cur, hash_val, hash_len)) {
+			if (DBGP(DBG_CRYPT)) {
+				DBG_dump("received 'informational':",
+					 hash_pbs->cur, pbs_left(hash_pbs));
+			}
+			loglog(RC_LOG_SERIOUS,
+			       "received 'informational' message HASH(1) data does not match computed value");
+			return;
+		} else {
+			DBG(DBG_CRYPT, DBG_log("received 'informational' message HASH(1) data ok"));
+		}
+	}
+
 	/* more sanity checking: enforce most ordering constraints */
 
 	if (IS_PHASE1(from_state) || IS_PHASE15(from_state)) {
diff --git a/programs/pluto/ikev1_quick.c b/programs/pluto/ikev1_quick.c
index 27b9a49..ed8fa02 100644
--- a/programs/pluto/ikev1_quick.c
+++ b/programs/pluto/ikev1_quick.c
@@ -662,10 +662,10 @@ static bool check_net_id(struct isakmp_ipsec_id *id,
  * Used by: quick_outI1, quick_inI1_outR1 (twice), quick_inR1_outI2
  * (see RFC 2409 "IKE" 5.5, pg. 18 or draft-ietf-ipsec-ike-01.txt 6.2 pg 25)
  */
-static size_t quick_mode_hash12(u_char *dest, const u_char *start,
-				const u_char *roof,
-				const struct state *st, const msgid_t *msgid,
-				bool hash2)
+size_t quick_mode_hash12(u_char *dest, const u_char *start,
+			 const u_char *roof,
+			 const struct state *st, const msgid_t *msgid,
+			 bool hash2)
 {
 	struct hmac_ctx ctx;
 
diff --git a/programs/pluto/ipsec_doi.h b/programs/pluto/ipsec_doi.h
index b48b6fc..a3ab1c8 100644
--- a/programs/pluto/ipsec_doi.h
+++ b/programs/pluto/ipsec_doi.h
@@ -119,6 +119,11 @@ extern notification_t accept_KE(chunk_t *dest, const char *val_name,
 		} \
 }
 
+size_t quick_mode_hash12(u_char *dest, const u_char *start,
+			 const u_char *roof,
+			 const struct state *st, const msgid_t *msgid,
+			 bool hash2);
+
 extern stf_status send_isakmp_notification(struct state *st,
 					   uint16_t type, const void *data,
 					   size_t len);
