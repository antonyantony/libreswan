From: Paul Wouters <pwouters@redhat.com>
Date: Sat, 28 Oct 2017 00:20:57 +0400
Subject: pluto: fix IS_IPSEC_SA_ESTABLISHED()

It was checking specific states, but that runs into our long term
issue of STATE_PARENT_R2 and STATE_PARENT_I3 being used for parent and
child states. So the macro really also needs to check st_clonedfrom !=
SOS_NOBODY

Looking at the macro, it would have acted wrongly for a few other items
too, luckilly mostly in the statsd logging.

(cherry picked from commit 7a3914f14cf7cb8c9276a7614376de91d626f0e0)
---
 include/pluto_constants.h   | 15 ++++++++-------
 programs/pluto/ikev1.c      |  4 ++--
 programs/pluto/ikev1_main.c |  2 +-
 programs/pluto/log.c        |  4 ++--
 programs/pluto/state.c      | 18 +++++++++---------
 5 files changed, 22 insertions(+), 21 deletions(-)

diff --git a/include/pluto_constants.h b/include/pluto_constants.h
index ff2556a..19be5ed 100644
--- a/include/pluto_constants.h
+++ b/include/pluto_constants.h
@@ -630,13 +630,14 @@ enum original_role {
 				LELEM(STATE_PARENT_I2))
 
 /* IKEv1 or IKEv2 */
-#define IS_IPSEC_SA_ESTABLISHED(s) ((s) == STATE_QUICK_I2 || \
-				    (s) == STATE_QUICK_R1 || \
-				    (s) == STATE_QUICK_R2 || \
-				    (s) == STATE_V2_IPSEC_I || \
-				    (s) == STATE_V2_IPSEC_R || \
-				    (s) == STATE_PARENT_I3 || \
-				    (s) == STATE_PARENT_R2)
+#define IS_IPSEC_SA_ESTABLISHED(s) (IS_CHILD_SA(s) && \
+				    ((s->st_state) == STATE_QUICK_I2 || \
+				    (s->st_state) == STATE_QUICK_R1 || \
+				    (s->st_state) == STATE_QUICK_R2 || \
+				    (s->st_state) == STATE_V2_IPSEC_I || \
+				    (s->st_state) == STATE_V2_IPSEC_R || \
+				    (s->st_state) == STATE_PARENT_I3 || \
+				    (s->st_state) == STATE_PARENT_R2))
 
 #define IS_MODE_CFG_ESTABLISHED(s) ((s) == STATE_MODE_CFG_R2)
 
diff --git a/programs/pluto/ikev1.c b/programs/pluto/ikev1.c
index b14256c..1288cbc 100644
--- a/programs/pluto/ikev1.c
+++ b/programs/pluto/ikev1.c
@@ -2477,7 +2477,7 @@ void complete_v1_state_transition(struct msg_digest **mdp, stf_status result)
 			sadetails[0] = '\0';
 
 			/* document IPsec SA details for admin's pleasure */
-			if (IS_IPSEC_SA_ESTABLISHED(st->st_state)) {
+			if (IS_IPSEC_SA_ESTABLISHED(st)) {
 				fmt_ipsec_sa_established(st, sadetails,
 							 sizeof(sadetails));
 				w = RC_SUCCESS; /* log our success */
@@ -2637,7 +2637,7 @@ void complete_v1_state_transition(struct msg_digest **mdp, stf_status result)
 		}
 
 		if (IS_ISAKMP_SA_ESTABLISHED(st->st_state) ||
-		    IS_IPSEC_SA_ESTABLISHED(st->st_state))
+		    IS_IPSEC_SA_ESTABLISHED(st))
 			release_whack(st);
 
 		if (IS_QUICK(st->st_state))
diff --git a/programs/pluto/ikev1_main.c b/programs/pluto/ikev1_main.c
index 8424500..e6c4d9f 100644
--- a/programs/pluto/ikev1_main.c
+++ b/programs/pluto/ikev1_main.c
@@ -2448,7 +2448,7 @@ bool ikev1_delete_out(struct state *st)
 	struct isakmp_hdr hdr;
 
 	/* If there are IPsec SA's related to this state struct... */
-	if (IS_IPSEC_SA_ESTABLISHED(st->st_state)) {
+	if (IS_IPSEC_SA_ESTABLISHED(st)) {
 		/* Find their phase1 state object */
 		p1st = find_phase1_state(st->st_connection,
 					ISAKMP_SA_ESTABLISHED_STATES);
diff --git a/programs/pluto/log.c b/programs/pluto/log.c
index c70f5f7..fc4745e 100644
--- a/programs/pluto/log.c
+++ b/programs/pluto/log.c
@@ -652,10 +652,10 @@ static void connection_state(struct state *st, void *data)
 			lc->tunnel = tun_phase15;
 	}
 
-	if (IS_QUICK(st->st_state)) {
+	if (IS_CHILD_SA(st)) {
 		if (lc->tunnel < tun_phase2)
 			lc->tunnel = tun_phase2;
-		if (IS_IPSEC_SA_ESTABLISHED(st->st_state)) {
+		if (IS_IPSEC_SA_ESTABLISHED(st)) {
 			if (lc->tunnel < tun_up)
 				lc->tunnel = tun_up;
 			lc->phase2 = p2_up;
diff --git a/programs/pluto/state.c b/programs/pluto/state.c
index 2402745..4915b1e 100644
--- a/programs/pluto/state.c
+++ b/programs/pluto/state.c
@@ -705,7 +705,7 @@ static void flush_pending_ipsec(struct state *pst, struct state *st)
 		char cib[CONN_INST_BUF];
 		struct connection *c = st->st_connection;
 
-		if (IS_IPSEC_SA_ESTABLISHED(st->st_state))
+		if (IS_IPSEC_SA_ESTABLISHED(st))
 			return;
 
 		delete_event(st);
@@ -747,7 +747,7 @@ static bool send_delete_check(const struct state *st)
 	if (st->st_ikev2_no_del)
 		return FALSE;
 
-	if (IS_IPSEC_SA_ESTABLISHED(st->st_state) ||
+	if (IS_IPSEC_SA_ESTABLISHED(st) ||
 			IS_ISAKMP_SA_ESTABLISHED(st->st_state))
 	{
 		if (st->st_ikev2 &&
@@ -854,7 +854,7 @@ void delete_state(struct state *st)
 		}
 	}
 
-	if (IS_IPSEC_SA_ESTABLISHED(st->st_state)) {
+	if (IS_IPSEC_SA_ESTABLISHED(st)) {
 		/* pull in the traffic counters into state before they're lost */
 		if (!get_sa_info(st, FALSE, NULL)) {
 			libreswan_log("failed to pull traffic counters from outbound IPsec SA");
@@ -997,7 +997,7 @@ void delete_state(struct state *st)
 	/*
 	 * tell kernel to delete any IPSEC SA
 	 */
-	if (IS_IPSEC_SA_ESTABLISHED(st->st_state) ||
+	if (IS_IPSEC_SA_ESTABLISHED(st) ||
 		IS_CHILD_SA_ESTABLISHED(st) ||
 		st->st_state == STATE_CHILDSA_DEL) {
 			delete_ipsec_sa(st);
@@ -1719,7 +1719,7 @@ struct state *find_phase2_state_to_delete(const struct state *p1st,
 		struct state *st;
 
 		FOR_EACH_ENTRY(st, i, {
-			if (IS_IPSEC_SA_ESTABLISHED(st->st_state) &&
+			if (IS_IPSEC_SA_ESTABLISHED(st) &&
 				p1st->st_connection->host_pair ==
 				st->st_connection->host_pair &&
 				same_peer_ids(p1st->st_connection,
@@ -1819,7 +1819,7 @@ void state_eroute_usage(const ip_subnet *ours, const ip_subnet *his,
 			struct connection *c = st->st_connection;
 
 			/* XXX spd-enum */
-			if (IS_IPSEC_SA_ESTABLISHED(st->st_state) &&
+			if (IS_IPSEC_SA_ESTABLISHED(st) &&
 				c->spd.eroute_owner == st->st_serialno &&
 				c->spd.routing == RT_ROUTED_TUNNEL &&
 				samesubnet(&c->spd.this.client, ours) &&
@@ -1860,7 +1860,7 @@ void fmt_list_traffic(struct state *st, char *state_buf,
 	if (IS_IKE_SA(st))
 		return; /* ignore non-IPsec states */
 
-	if (!IS_IPSEC_SA_ESTABLISHED(st->st_state))
+	if (!IS_IPSEC_SA_ESTABLISHED(st))
 		return; /* ignore non established states */
 
 	fmt_conn_instance(c, inst);
@@ -1954,7 +1954,7 @@ void fmt_state(struct state *st, const monotime_t n,
 	}
 
 	dpdbuf[0] = '\0';	/* default to empty string */
-	if (IS_IPSEC_SA_ESTABLISHED(st->st_state)) {
+	if (IS_IPSEC_SA_ESTABLISHED(st)) {
 		snprintf(dpdbuf, sizeof(dpdbuf), "; isakmp#%lu",
 			 (unsigned long)st->st_clonedfrom);
 	} else {
@@ -2007,7 +2007,7 @@ void fmt_state(struct state *st, const monotime_t n,
 	/* print out SPIs if SAs are established */
 	if (state_buf2_len != 0)
 		state_buf2[0] = '\0';   /* default to empty */
-	if (IS_IPSEC_SA_ESTABLISHED(st->st_state)) {
+	if (IS_IPSEC_SA_ESTABLISHED(st)) {
 		char lastused[40];      /* should be plenty long enough */
 		char buf[SATOT_BUF * 6 + 1];
 		char *p = buf;
