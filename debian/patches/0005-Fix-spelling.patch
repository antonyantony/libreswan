From: Daniel Kahn Gillmor <dkg@fifthhorseman.net>
Date: Mon, 5 Feb 2018 16:12:40 -0500
Subject: Fix spelling

More orthographic nit-picking.

Signed-off-by: Daniel Kahn Gillmor <dkg@fifthhorseman.net>
---
 CHANGES                                                        | 4 ++--
 include/ike_alg.h                                              | 8 ++++----
 include/ike_alg_null.h                                         | 2 +-
 include/ip_address.h                                           | 2 +-
 include/pluto_constants.h                                      | 2 +-
 include/unbound/unbound-event.h                                | 2 +-
 lib/libswan/Makefile                                           | 2 +-
 lib/libswan/lswlog.c                                           | 2 +-
 lib/libswan/secrets.c                                          | 2 +-
 mk/kvm-targets.mk                                              | 4 ++--
 mk/targets.mk                                                  | 2 +-
 programs/configs/d.ipsec.conf/modecfgoptions.xml               | 4 ++--
 programs/configs/ipsec.secrets.5.xml                           | 2 +-
 programs/pluto/crypt_dh.c                                      | 4 ++--
 programs/pluto/ikev1_xauth.c                                   | 2 +-
 programs/pluto/ikev2.c                                         | 4 ++--
 programs/pluto/ikev2_parent.c                                  | 4 ++--
 programs/pluto/log.c                                           | 2 +-
 programs/pluto/log.h                                           | 2 +-
 programs/pluto/pluto_crypt.h                                   | 6 +++---
 programs/pluto/server.c                                        | 2 +-
 programs/pluto/x509.c                                          | 2 +-
 testing/enumcheck/enumcheck.c                                  | 2 +-
 testing/pluto/addconn-02/description.txt                       | 2 +-
 testing/pluto/addconn-03/description.txt                       | 2 +-
 testing/pluto/ikev2-55-ipseckey-06/description.txt             | 2 +-
 testing/pluto/ikev2-56-restart/eastinit.sh                     | 2 +-
 testing/pluto/ikev2-59-multiple-acquires-alias/description.txt | 2 +-
 testing/pluto/ikev2-60-pam/mypam.c                             | 4 ++--
 testing/pluto/ikev2-child-ipsec-pfs-nhelpers-0/description.txt | 2 +-
 testing/pluto/nat-pluto-11/description.txt                     | 2 +-
 testing/pluto/xauth-pluto-20-pam-timeout/mypam.c               | 4 ++--
 testing/sanitizers/ip-xfrm.sed                                 | 2 +-
 testing/utils/fab/post.py                                      | 4 ++--
 testing/utils/fab/publish.py                                   | 2 +-
 testing/utils/fab/runner.py                                    | 2 +-
 testing/utils/kvmresults.py                                    | 2 +-
 testing/utils/swantest                                         | 4 ++--
 testing/web/README.md                                          | 2 +-
 testing/web/gime-work.sh                                       | 4 ++--
 40 files changed, 56 insertions(+), 56 deletions(-)

diff --git a/CHANGES b/CHANGES
index b85315d..c97b09c 100644
--- a/CHANGES
+++ b/CHANGES
@@ -16,7 +16,7 @@ v3.23 (January 25, 2018)
 * pluto: add --impair replay-forward,replay-backward [Andrew]
 * pluto: add --impair dup-incoming-packets [Andrew]
 * pluto: Rework nic offload detection code [Aviv Heller]
-* pluto: Retry send on -EAGAIN in check_msg_errqueue() (upto 32x) [Paul/Hugh]
+* pluto: Retry send on -EAGAIN in check_msg_errqueue() (up to 32x) [Paul/Hugh]
 * pluto: Pull latest kernel traffic counters before logging/deleting SA [Paul]
 * pluto: STF_INLINE, STF_TOOMUCHCRYPTO no longer needed in helpers [Andrew]
 * pluto: Replace socket queues with a simple queue and mutex+cont [Andrew]
@@ -153,7 +153,7 @@ v3.21 (August 9, 2017)
 * IKEv2: OE client check should take responders behind NAT into account [Paul]
 * IKEv2: Improved dpdaction=hold processing [Antony]
 * IKEv1: Only initiate and create IKE SA for appropriate dpdaction [Antony]
-* IKEv1: Re-add SHA2_256 (prefered) and SHA2_512 to IKEv1 defaults [Andrew]
+* IKEv1: Re-add SHA2_256 (preferred) and SHA2_512 to IKEv1 defaults [Andrew]
 * IKEv1: Aggressive Mode fixes for sending CERT / CERTREQ payloads [Paul]
 * IKEv1: Multiple CISCO_SPLIT_INC's cause duplicate spd_routes [Oleg Rosowiecki]
 * X509: Improve some failure logging [Paul]
diff --git a/include/ike_alg.h b/include/ike_alg.h
index 7c20d05..eba6c5c 100644
--- a/include/ike_alg.h
+++ b/include/ike_alg.h
@@ -348,7 +348,7 @@ struct encrypt_desc {
 
 struct encrypt_ops {
 	/*
-	 * Delegate responsiblity for checking OPS specific fields.
+	 * Delegate responsibility for checking OPS specific fields.
 	 */
 	void (*const check)(const struct encrypt_desc *alg);
 
@@ -425,7 +425,7 @@ struct hash_context;
 
 struct hash_ops {
 	/*
-	 * Delegate responsiblity for checking OPS specific fields.
+	 * Delegate responsibility for checking OPS specific fields.
 	 */
 	void (*const check)(const struct hash_desc *alg);
 
@@ -514,7 +514,7 @@ struct prf_desc {
 
 struct prf_ops {
 	/*
-	 * Delegate responsiblity for checking OPS specific fields.
+	 * Delegate responsibility for checking OPS specific fields.
 	 */
 	void (*const check)(const struct prf_desc *alg);
 
@@ -665,7 +665,7 @@ struct oakley_group_desc {
 
 struct dhmke_ops {
 	/*
-	 * Delegate responsiblity for checking OPS specific fields.
+	 * Delegate responsibility for checking OPS specific fields.
 	 */
 	void (*const check)(const struct oakley_group_desc *alg);
 
diff --git a/include/ike_alg_null.h b/include/ike_alg_null.h
index c74b05d..fa1d8bb 100644
--- a/include/ike_alg_null.h
+++ b/include/ike_alg_null.h
@@ -17,7 +17,7 @@
 extern const struct encrypt_desc ike_alg_encrypt_null;
 
 /*
- * IKEv2 RFC 7296 uses the term "NONE" when refering to no integrity.
+ * IKEv2 RFC 7296 uses the term "NONE" when referring to no integrity.
  * For instance: ... MUST either offer no integrity algorithm or a
  * single integrity algorithm of "NONE"
  */
diff --git a/include/ip_address.h b/include/ip_address.h
index 032a24d..a1b3ea6 100644
--- a/include/ip_address.h
+++ b/include/ip_address.h
@@ -22,7 +22,7 @@ struct lswlog;
 
 /*
  * The type IP_ADDRESS is shared between KLIPS (kernel module) and
- * PLUTO.  Its definition is burried in the common include file
+ * PLUTO.  Its definition is buried in the common include file
  * "libreswan.h".
  *
  * This header contains declarations for userland specific extensions.
diff --git a/include/pluto_constants.h b/include/pluto_constants.h
index 5e3d67e..572a73b 100644
--- a/include/pluto_constants.h
+++ b/include/pluto_constants.h
@@ -204,7 +204,7 @@ enum event_type {
 #endif
 #define DELETE_SA_DELAY			RETRANSMIT_TIMEOUT_DEFAULT /* wait until the other side giveup on us */
 #define EVENT_CRYPTO_TIMEOUT_DELAY	RETRANSMIT_TIMEOUT_DEFAULT /* wait till the other side give up on us */
-#define EVENT_PAM_TIMEOUT_DELAY		RETRANSMIT_TIMEOUT_DEFAULT /* wait untill this side give up on PAM */
+#define EVENT_PAM_TIMEOUT_DELAY		RETRANSMIT_TIMEOUT_DEFAULT /* wait until this side give up on PAM */
 
 /*
  * operational importance of this cryptographic operation.
diff --git a/include/unbound/unbound-event.h b/include/unbound/unbound-event.h
index 432750d..24ed8cd 100644
--- a/include/unbound/unbound-event.h
+++ b/include/unbound/unbound-event.h
@@ -41,7 +41,7 @@
  *
  * Use ub_ctx_create_event_ub_base() to create an unbound context that uses
  * the user provided event base API.  Then, use the ub_resolve_event call
- * to add DNS resolve queries to the context.  Those then run whith the
+ * to add DNS resolve queries to the context.  Those then run with the
  * provided event_base, and when they are done you get a function callback.
  *
  * This method does not fork another process or create a thread, the effort
diff --git a/lib/libswan/Makefile b/lib/libswan/Makefile
index 7c87cd1..1007ef6 100644
--- a/lib/libswan/Makefile
+++ b/lib/libswan/Makefile
@@ -92,7 +92,7 @@ OBJS += lswlog_passert.o
 
 # Crypto code:
 #
-# XXX: More is comming as it gets cleaned up and made more library
+# XXX: More is coming as it gets cleaned up and made more library
 # like.
 
 # not much left using this
diff --git a/lib/libswan/lswlog.c b/lib/libswan/lswlog.c
index fa93f4d..283bda3 100644
--- a/lib/libswan/lswlog.c
+++ b/lib/libswan/lswlog.c
@@ -183,7 +183,7 @@ static size_t append(struct lswlog *log, const char *format, va_list ap)
 	 * to the buffer.
 	 *
 	 * If N is negative than an "output error" (will that happen?)
-	 * occured (that or a very old, non-compliant, s*printf()
+	 * occurred (that or a very old, non-compliant, s*printf()
 	 * implementation that returns -1 instead of the required
 	 * size).
 	 */
diff --git a/lib/libswan/secrets.c b/lib/libswan/secrets.c
index 59e0dac..5d1f600 100644
--- a/lib/libswan/secrets.c
+++ b/lib/libswan/secrets.c
@@ -795,7 +795,7 @@ static err_t lsw_process_ppk_dynamic_secret(chunk_t *ppk, chunk_t *ppk_id, char
 		(void) shift();
 		if (lexopen(&new_pos, fn, FALSE)) {
 			int offset = 0;
-			DBG(DBG_CONTROL, DBG_log("OTP file opened succesfully"));
+			DBG(DBG_CONTROL, DBG_log("OTP file opened successfully"));
 
 			*filename = clone_bytes(&fn, len + 1, "Dynamic PPK filename");
 			DBG(DBG_CONTROL, DBG_log("Processing dynamic secret, saving filename as: %s", *filename));
diff --git a/mk/kvm-targets.mk b/mk/kvm-targets.mk
index d684e21..2c28ed0 100644
--- a/mk/kvm-targets.mk
+++ b/mk/kvm-targets.mk
@@ -785,7 +785,7 @@ $(foreach domain, $(KVM_LOCAL_DOMAINS), \
 # uninstall-kvm-domain-clone isn't run until all its dependencies,
 # such as uninstall-kvm-domain-build, have been run.  Using
 # kvm-uninstall-* rules leads to indirect dependencies and
-# out-of-order distruction.
+# out-of-order destruction.
 
 $(addprefix uninstall-kvm-domain-, $(KVM_CLONE_DOMAIN)): \
 	$(addprefix uninstall-kvm-domain-, $(KVM_CLONE_COPIES))
@@ -1115,7 +1115,7 @@ Configuration:
       $(call kvm-var-value,KVM_BASEDIR)$(if $(wildcard $(KVM_BASEDIR)),, [MISSING])
 
           for storing the shared base (master) VM; should be
-          relatively permenant storage
+          relatively permanent storage
 
       $(call kvm-var-value,KVM_LOCALDIR)$(if $(wildcard $(KVM_LOCALDIR)),, [MISSING])
 
diff --git a/mk/targets.mk b/mk/targets.mk
index 783a032..594efb1 100644
--- a/mk/targets.mk
+++ b/mk/targets.mk
@@ -49,7 +49,7 @@ define recursive-target
 
   # Force recursion before running the local target.  While this is
   # what make systems like autoconf do, pluto was for a very long time
-  # doing the oposite - doing the recursion last.
+  # doing the opposite - doing the recursion last.
 
   $(1): recursive-$(1)
 	@$$(MAKE) --no-print-directory local-$(1)
diff --git a/programs/configs/d.ipsec.conf/modecfgoptions.xml b/programs/configs/d.ipsec.conf/modecfgoptions.xml
index 9ae3400..ce92170 100644
--- a/programs/configs/d.ipsec.conf/modecfgoptions.xml
+++ b/programs/configs/d.ipsec.conf/modecfgoptions.xml
@@ -10,8 +10,8 @@ will use these received options to either update /etc/resolv.conf or the running
 server. When the connection is brought down, the previous DNS resolving state is restored.
 </para>
 <para>
-The modecfgdns option takes a comma or space seperated list of IP addresses that can be used
-for DNS resolution. The modecfgdomains option takes a comma or space seperated list of internal
+The modecfgdns option takes a comma or space separated list of IP addresses that can be used
+for DNS resolution. The modecfgdomains option takes a comma or space separated list of internal
 domain names that are reachable via the supplied modecfgdns DNS servers.
 </para>
 <para>The IKEv1 split tunnel directive will be sent automatically if the xauth server side has
diff --git a/programs/configs/ipsec.secrets.5.xml b/programs/configs/ipsec.secrets.5.xml
index 98f4e0a..05c7a1d 100644
--- a/programs/configs/ipsec.secrets.5.xml
+++ b/programs/configs/ipsec.secrets.5.xml
@@ -182,7 +182,7 @@ In both cases, the next token is a PPK_ID that uniquely represent the given PPK.
 delimited by the double-quote character (<emphasis remap='B'>"</emphasis>).
 If PPK is a static one, then the next token is a PPK, otherwise the next token is a filename of a file that has a dynamic PPK.
 Dynamic PPK is one-time pad. Dynamic PPK file has a offset in it's first token. This offset should be number delimited by the
-double-quote character (<emphasis remap='B'>"</emphasis>). Second token is a OTP which the PPK will be extracted from. Everytime
+double-quote character (<emphasis remap='B'>"</emphasis>). Second token is a OTP which the PPK will be extracted from. Every time
 one PPK hase been extracted, the offset is increased in the size of the PPK. When first time used, the offset should be given
 in a format "00...00".
 PPK may be represented in any format which can be used for representing a preshared secret.</para>
diff --git a/programs/pluto/crypt_dh.c b/programs/pluto/crypt_dh.c
index 6452bdd..7f36702 100644
--- a/programs/pluto/crypt_dh.c
+++ b/programs/pluto/crypt_dh.c
@@ -135,7 +135,7 @@ void transfer_dh_secret_to_state(const char *helper, struct dh_secret **secret,
 {
 	LSWDBGP(DBG_CRYPT, buf) {
 		lswlog_dh_secret(buf, *secret);
-		lswlogf(buf, "transfering ownership from helper %s to state #%lu",
+		lswlogf(buf, "transferring ownership from helper %s to state #%lu",
 			helper, st->st_serialno);
 	}
 	pexpect(st->st_dh_secret == NULL);
@@ -148,7 +148,7 @@ void transfer_dh_secret_to_helper(struct state *st,
 {
 	LSWDBGP(DBG_CRYPT, buf) {
 		lswlog_dh_secret(buf, st->st_dh_secret);
-		lswlogf(buf, "transfering ownership from state #%lu to helper %s",
+		lswlogf(buf, "transferring ownership from state #%lu to helper %s",
 			st->st_serialno, helper);
 	}
 	pexpect(*secret == NULL);
diff --git a/programs/pluto/ikev1_xauth.c b/programs/pluto/ikev1_xauth.c
index f12dff6..f44db15 100644
--- a/programs/pluto/ikev1_xauth.c
+++ b/programs/pluto/ikev1_xauth.c
@@ -307,7 +307,7 @@ static stf_status isakmp_add_attr(pb_stream *strattr,
 	case MODECFG_DOMAIN:
 	{
 		/*
-		 * IKEv2 allows more then one, seperated by comma or space
+		 * IKEv2 allows more then one, separated by comma or space
 		 * We don't know if existing IKEv1 implementations support
 		 * more then one, so we just send the first one configured.
 		 */
diff --git a/programs/pluto/ikev2.c b/programs/pluto/ikev2.c
index 9a03b88..019fba3 100644
--- a/programs/pluto/ikev2.c
+++ b/programs/pluto/ikev2.c
@@ -125,7 +125,7 @@ enum smf2_flags {
 	 * The original responder, when it receives the encrypted AUTH
 	 * payload, isn't yet ready to decrypt it - receiving the
 	 * packet is what triggers the DH calculation needed before
-	 * encryption can occure.
+	 * encryption can occur.
 	 */
 	SMF2_SKIP_UNPACK_SK = LELEM(7),
 };
@@ -1318,7 +1318,7 @@ void process_v2_packet(struct msg_digest **mdp)
 		passert(st != NULL);
 
 		/*
-		 * Since the encrypted payload appears plausable, deal
+		 * Since the encrypted payload appears plausible, deal
 		 * with fragmentation.
 		 */
 		if (encrypted_payload_summary.status == STF_ROOF) {
diff --git a/programs/pluto/ikev2_parent.c b/programs/pluto/ikev2_parent.c
index ac59ecd..62cf234 100644
--- a/programs/pluto/ikev2_parent.c
+++ b/programs/pluto/ikev2_parent.c
@@ -232,7 +232,7 @@ static stf_status add_st_send_list(struct state *st, struct state *pst)
 		}
 	}
 	DBG(DBG_CONTROLMORE,
-		DBG_log("#%lu %s using parent #%lu unacknowledged %u next message id=%u ike excange window %u",
+		DBG_log("#%lu %s using parent #%lu unacknowledged %u next message id=%u ike exchange window %u",
 			st->st_serialno,
 			what, pst->st_serialno, unack,
 			pst->st_msgid_nextuse,
@@ -6706,7 +6706,7 @@ void ikev2_child_outI(struct state *st)
 
 /*
  * if this connection has a newer Child SA than this state
- * this negotitation is not relevent any more.
+ * this negotitation is not relevant any more.
  * would this cover if there are multiple CREATE_CHILD_SA pending on
  * this IKE negotiation ???
  */
diff --git a/programs/pluto/log.c b/programs/pluto/log.c
index e0aab13..9c2abf5 100644
--- a/programs/pluto/log.c
+++ b/programs/pluto/log.c
@@ -472,7 +472,7 @@ static void add_whack_rc_prefix(struct lswlog *buf, enum rc_type rc)
 }
 
 /*
- * Wrap up the logic to decide if a particular output should occure.
+ * Wrap up the logic to decide if a particular output should occur.
  * The compiler will likely inline these.
  */
 
diff --git a/programs/pluto/log.h b/programs/pluto/log.h
index 5a1806f..26fb64d 100644
--- a/programs/pluto/log.h
+++ b/programs/pluto/log.h
@@ -134,7 +134,7 @@ extern void close_log(void);
 extern void exit_log(const char *message, ...) PRINTF_LIKE(1) NEVER_RETURNS;
 
 /*
- * struct lswlog primatives
+ * struct lswlog primitives
  */
 bool whack_log_p(void);
 void whack_log_pre(enum rc_type rc, struct lswlog *buf);
diff --git a/programs/pluto/pluto_crypt.h b/programs/pluto/pluto_crypt.h
index 82b9f09..34adb8a 100644
--- a/programs/pluto/pluto_crypt.h
+++ b/programs/pluto/pluto_crypt.h
@@ -264,18 +264,18 @@ struct pluto_crypto_req_cont;	/* forward reference */
  *
  * struct msg_digest *md:
  *
- *      If applicable, the incomming packet that triggered the
+ *      If applicable, the incoming packet that triggered the
  *      requested crypto.  Re-keying, for instance, will not have this
  *      packet?
  *
  *      This function is responsible for either releasing or
- *      transfering ownership of the MD.
+ *      transferring ownership of the MD.
  *
  * struct pluto_crypto_req *r:
  *
  *	The results from the crypto operation.
  *
- *      This function is responsible for releasing or transfering the
+ *      This function is responsible for releasing or transferring the
  *      contents (and for "just knowing" the right contents in the
  *      union it should be using).
  *
diff --git a/programs/pluto/server.c b/programs/pluto/server.c
index 932a682..d42042e 100644
--- a/programs/pluto/server.c
+++ b/programs/pluto/server.c
@@ -1395,7 +1395,7 @@ bool check_msg_errqueue(const struct iface_port *ifp, short interest, const char
 					 * behaviour can be restored?
 					 *
 					 * HACK: So that the logging
-					 * system doesn't accidently
+					 * system doesn't accidentally
 					 * include a prefix for the
 					 * wrong state et.al., switch
 					 * out everything but SENDER.
diff --git a/programs/pluto/x509.c b/programs/pluto/x509.c
index a33042e..2f1bb89 100644
--- a/programs/pluto/x509.c
+++ b/programs/pluto/x509.c
@@ -817,7 +817,7 @@ static int pluto_process_certs(struct state *st, chunk_t *certs,
 			break;
 
 		case ID_FROMCERT:
-			/* We are commited to accept any ID as long as the CERT verified */
+			/* We are committed to accept any ID as long as the CERT verified */
 			st->st_peer_alt_id = TRUE;
 			cont = LSW_CERT_ID_OK;
 			idtoa(&c->spd.that.id, namebuf, sizeof(namebuf));
diff --git a/testing/enumcheck/enumcheck.c b/testing/enumcheck/enumcheck.c
index 129897d..4b39397 100644
--- a/testing/enumcheck/enumcheck.c
+++ b/testing/enumcheck/enumcheck.c
@@ -41,7 +41,7 @@ static void test_enum(enum_names *enum_test, int i,
 
 	/*
 	 * So that it is easy to see what was tested, print something
-	 * for every comparision.
+	 * for every comparison.
 	 */
 
 	if (i < 0) {
diff --git a/testing/pluto/addconn-02/description.txt b/testing/pluto/addconn-02/description.txt
index b3e534a..3bb2124 100644
--- a/testing/pluto/addconn-02/description.txt
+++ b/testing/pluto/addconn-02/description.txt
@@ -1,4 +1,4 @@
-addconn failing in libreswan upto 3.21 when asking for the
+addconn failing in libreswan up to 3.21 when asking for the
 routes exceeds the netlink message buffer. It caused addconn
 to fail to orient a left=%defaulroute connection.
 
diff --git a/testing/pluto/addconn-03/description.txt b/testing/pluto/addconn-03/description.txt
index 61ab8e7..02a6579 100644
--- a/testing/pluto/addconn-03/description.txt
+++ b/testing/pluto/addconn-03/description.txt
@@ -1,4 +1,4 @@
-addconn failing in libreswan upto 3.21 in specific scenarios
+addconn failing in libreswan up to 3.21 in specific scenarios
 
 east is not used.
 
diff --git a/testing/pluto/ikev2-55-ipseckey-06/description.txt b/testing/pluto/ikev2-55-ipseckey-06/description.txt
index 4d1d44c..9b550b9 100644
--- a/testing/pluto/ikev2-55-ipseckey-06/description.txt
+++ b/testing/pluto/ikev2-55-ipseckey-06/description.txt
@@ -1,7 +1,7 @@
 The responder failto validate IPSECKEY of initiator and A record.
 
 Road is the initiator and east is the responder.
-Road has acces to nort's key, it has public and private key.
+Road has access to north's key, it has public and private key.
 
 When road initiate the connection, it send an IKE request, and
 simultaneously start query for the responders IPSECKEY in reverse zone.
diff --git a/testing/pluto/ikev2-56-restart/eastinit.sh b/testing/pluto/ikev2-56-restart/eastinit.sh
index a46e8a0..153b721 100755
--- a/testing/pluto/ikev2-56-restart/eastinit.sh
+++ b/testing/pluto/ikev2-56-restart/eastinit.sh
@@ -1,6 +1,6 @@
 /testing/guestbin/swan-prep
 ipsec start
 /testing/pluto/bin/wait-until-pluto-started
-echo "Leave ping running continously in the background "
+echo "Leave ping running continuously in the background "
 ping -n -I 192.0.2.254 192.0.1.254 2>&1 > /dev/null &
 echo "initdone"
diff --git a/testing/pluto/ikev2-59-multiple-acquires-alias/description.txt b/testing/pluto/ikev2-59-multiple-acquires-alias/description.txt
index 9fdd976..a667e0d 100644
--- a/testing/pluto/ikev2-59-multiple-acquires-alias/description.txt
+++ b/testing/pluto/ikev2-59-multiple-acquires-alias/description.txt
@@ -1,2 +1,2 @@
 This is an IKEv2 test with alias/subnets using ipsec auto --up
-The test output is not stable enough to be commited as good console output.
+The test output is not stable enough to be committed as good console output.
diff --git a/testing/pluto/ikev2-60-pam/mypam.c b/testing/pluto/ikev2-60-pam/mypam.c
index 4e7e549..7e3c2d3 100644
--- a/testing/pluto/ikev2-60-pam/mypam.c
+++ b/testing/pluto/ikev2-60-pam/mypam.c
@@ -1,8 +1,8 @@
 
 /* simple test program from https://github.com/beatgammit/simple-pam */
 
-/* "gooduser60" will just sleep for 60 seconds and return sucess */
-/* "gooduser90" will just sleep for 90 secods and return sucess */
+/* "gooduser60" will just sleep for 60 seconds and return success */
+/* "gooduser90" will just sleep for 90 secods and return success */
 /* "gooduser" will always succeed with "right" password - everything else fails */
 /* "@road" will always succeed with "right" password - everything else fails */
 
diff --git a/testing/pluto/ikev2-child-ipsec-pfs-nhelpers-0/description.txt b/testing/pluto/ikev2-child-ipsec-pfs-nhelpers-0/description.txt
index 5bef90d..410245e 100644
--- a/testing/pluto/ikev2-child-ipsec-pfs-nhelpers-0/description.txt
+++ b/testing/pluto/ikev2-child-ipsec-pfs-nhelpers-0/description.txt
@@ -1,4 +1,4 @@
-Test CREATE_CHILD_SA to create additonal Child SA, with nhelpers=0 and pfs=yes
+Test CREATE_CHILD_SA to create additional Child SA, with nhelpers=0 and pfs=yes
 
 The crypto work will be done inline.
 West has two connections to east. Both will share one IKE SA.
diff --git a/testing/pluto/nat-pluto-11/description.txt b/testing/pluto/nat-pluto-11/description.txt
index b37e8b3..9ec9f1c 100644
--- a/testing/pluto/nat-pluto-11/description.txt
+++ b/testing/pluto/nat-pluto-11/description.txt
@@ -1,4 +1,4 @@
-This tests forcing of non-encapsulation and omiting sending NAT-T payloads
+This tests forcing of non-encapsulation and omitting sending NAT-T payloads
 to prevent NAT-T negotiation.
 
 east is behind a static portforward of nic for this to work
diff --git a/testing/pluto/xauth-pluto-20-pam-timeout/mypam.c b/testing/pluto/xauth-pluto-20-pam-timeout/mypam.c
index 6cf6762..8e64841 100644
--- a/testing/pluto/xauth-pluto-20-pam-timeout/mypam.c
+++ b/testing/pluto/xauth-pluto-20-pam-timeout/mypam.c
@@ -1,8 +1,8 @@
 
 /* simple test program from https://github.com/beatgammit/simple-pam */
 
-/* "gooduser60" will just sleep for 60 seconds and return sucess */
-/* "gooduser90" will just sleep for 90 secods and return sucess */
+/* "gooduser60" will just sleep for 60 seconds and return success */
+/* "gooduser90" will just sleep for 90 secods and return success */
 /* "gooduser" will always succeed with "right" password - everything else fails */
 
 #include <stdio.h>
diff --git a/testing/sanitizers/ip-xfrm.sed b/testing/sanitizers/ip-xfrm.sed
index 95255f1..03ebbb4 100644
--- a/testing/sanitizers/ip-xfrm.sed
+++ b/testing/sanitizers/ip-xfrm.sed
@@ -1,5 +1,5 @@
 # this an aggressive sanitizer for "ip xfrm state" esp
-# carefull when mxixing this with "ipsec look"
+# careful when mxixing this with "ipsec look"
 # "ipsec look" sanitizer are similar
 /src 0.0.0.0\/0 dst 0.0.0.0\/0/d
 /socket \(in\|out\) priority 0 ptype main/d
diff --git a/testing/utils/fab/post.py b/testing/utils/fab/post.py
index d70460c..b72b97f 100644
--- a/testing/utils/fab/post.py
+++ b/testing/utils/fab/post.py
@@ -70,7 +70,7 @@ class Resolution:
 #   contains a list (set?) of hosts
 #
 #   This is so that code can easily determine if a specific issue,
-#   regardless of the HOST, has occured.  All the programatic
+#   regardless of the HOST, has occurred.  All the programatic
 #   operators, such as __contains__(), are implemented based on this
 #   model.
 #
@@ -140,7 +140,7 @@ class Issues:
 
     # Programatic collections like interface.  This is indexed by
     # ISSUE so that it is easy to query Issues to see if an ISSUE
-    # occured on any host.
+    # occurred on any host.
 
     def __bool__(self):
         return len(self._issue_hosts) > 0
diff --git a/testing/utils/fab/publish.py b/testing/utils/fab/publish.py
index 5aab7b8..e4b0251 100644
--- a/testing/utils/fab/publish.py
+++ b/testing/utils/fab/publish.py
@@ -189,7 +189,7 @@ def json_result(logger, args, result):
     _add(JSON_SUMMARY, "totals", result.test.kind, result.test.status, str(result.resolution))
     for issue in result.issues:
         for domain in result.issues[issue]:
-            # count the number of times it occured
+            # count the number of times it occurred
             _add(JSON_SUMMARY, "errors", issue)
     # extend the times
     _update_time(min, "start_time", json_result)
diff --git a/testing/utils/fab/runner.py b/testing/utils/fab/runner.py
index 7339d17..1f2e02e 100644
--- a/testing/utils/fab/runner.py
+++ b/testing/utils/fab/runner.py
@@ -412,7 +412,7 @@ def _process_test(domain_prefix, test, args, test_stats, result_stats, test_coun
                         except pexpect.TIMEOUT as e:
                             # A test ending with a timeout gets
                             # treated as unresolved.  Timeouts
-                            # shouldn't occure so human intervention
+                            # shouldn't occur so human intervention
                             # is required.
                             logger.error("**** timeout out while running test script %s ****", script)
 
diff --git a/testing/utils/kvmresults.py b/testing/utils/kvmresults.py
index 987deff..6eaee43 100755
--- a/testing/utils/kvmresults.py
+++ b/testing/utils/kvmresults.py
@@ -191,7 +191,7 @@ def results(logger, tests, baseline, args, result_stats):
             # be cheap (does OUTPUT/ exist?).  It isn't, instead a
             # full post-mortem analysis is performed.
             #
-            # This is noticable when printing static test value such
+            # This is noticeable when printing static test value such
             # as the test's name takes far longer than one would
             # expect.
             result = post.mortem(test, args,
diff --git a/testing/utils/swantest b/testing/utils/swantest
index 178baaf..fae4b05 100755
--- a/testing/utils/swantest
+++ b/testing/utils/swantest
@@ -1225,7 +1225,7 @@ def sent_virsh_cmd(args, all_hosts, c="shutdown"):
     tries = args.shutdownwait
     while len(running) and tries != 0:
         logging.info(
-            "Found %s guests [%s] running. Wait upto %d seconds to shutdown", len(
+            "Found %s guests [%s] running. Wait up to %d seconds to shutdown", len(
                 running),
             ' '.join(map(str, running)), tries)
 
@@ -2740,7 +2740,7 @@ def setup_result_dir(args, to_create):
         os.chdir(cwd)
         logging.debug("cd %s; %s ; IPSECVERSION %s", dn, cmd, ipsecversion)
     else:
-        logging.debug("IPSECVERSION %s was set in enviroment", ipsecversion)
+        logging.debug("IPSECVERSION %s was set in environment", ipsecversion)
 
     if ipsecversion and args.rerun:
         output_dir = output_dir + ipsecversion
diff --git a/testing/web/README.md b/testing/web/README.md
index 7e690c6..4e9af2f 100644
--- a/testing/web/README.md
+++ b/testing/web/README.md
@@ -157,7 +157,7 @@ above), the testing script is invoked as:
 
 From time to time the test results are seen to decay.  The symptom is
 an increasing number of test failures with a result of "unresolved"
-and an error of "output-missing".  The error occures because one or
+and an error of "output-missing".  The error occurs because one or
 more test domains fail to start in a timely manner (the test runner
 gives up after two minutes), hence, while the test is processed there
 is never any output.
diff --git a/testing/web/gime-work.sh b/testing/web/gime-work.sh
index a89d201..7ef345a 100755
--- a/testing/web/gime-work.sh
+++ b/testing/web/gime-work.sh
@@ -132,7 +132,7 @@ while read hashes ; do
     fi
 
     # If this is a really interesting commit (branch, merge, tag),
-    # increment the bias so that earlier runs are prefered.  Do this
+    # increment the bias so that earlier runs are preferred.  Do this
     # before discarding tested commits so that nothing is missed.
     # This somewhat double counts as both merge and branch points are
     # considered.
@@ -155,7 +155,7 @@ while read hashes ; do
     # and not just a simple change).
     #
     # Keep processing as still need to determine the longest run.  The
-    # longest run may occure after this commit.  The only way to
+    # longest run may occur after this commit.  The only way to
     # determine that the longest run is before the first branch (say)
     # is to examining all commits.
 
